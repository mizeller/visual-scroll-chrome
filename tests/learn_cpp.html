<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6.1 — Operator precedence and associativity | Learn C++</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            color: #333;
        }
        .cpp-section {
            font-size: 1.2em;
            font-weight: bold;
            color: #0066cc;
            margin: 20px 0 10px 0;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .cpp-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .cpp-table th, .cpp-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            vertical-align: top;
        }
        .cpp-table th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        .cpp-note {
            margin: 20px 0;
            padding: 15px;
            border-left: 4px solid;
            border-radius: 4px;
        }
        .cpp-lightbluebackground {
            background-color: #e6f3ff;
            border-left-color: #0099cc;
        }
        .cpp-lightgreenbackground {
            background-color: #f0f8f0;
            border-left-color: #00aa00;
        }
        .cpp-lightgraybackground {
            background-color: #f8f8f8;
            border-left-color: #666;
        }
        .cpp-lightredbackground {
            background-color: #ffe6e6;
            border-left-color: #cc0000;
        }
        .cpp-note-title {
            font-weight: bold;
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #ddd;
        }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            border: 1px solid #ddd;
        }
        code {
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        .quiz {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .quiz-header {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #0066cc;
        }
        .wphint, .wpsolution {
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
        .hint_link_show, .solution_link_show {
            color: #0066cc;
            cursor: pointer;
            text-decoration: underline;
        }
        .prevnext {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }
        .nav-button {
            display: inline-block;
            padding: 10px 15px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 5px;
            text-decoration: none;
            color: #333;
        }
        .nav-button:hover {
            background-color: #e0e0e0;
        }
    </style>
    <script>
        function cppHintToggle(element, link, showText, hideText) {
            if (element.style.display === 'none') {
                element.style.display = 'block';
                link.innerHTML = hideText || 'Hide Hint';
            } else {
                element.style.display = 'none';
                link.innerHTML = showText;
            }
        }

        function cppSolutionToggle(element, link, showText, hideText) {
            if (element.style.display === 'none') {
                element.style.display = 'block';
                link.innerHTML = hideText;
            } else {
                element.style.display = 'none';
                link.innerHTML = showText;
            }
        }
    </script>
</head>
<body>

<h1>6.1 — Operator precedence and associativity</h1>

<p class="cpp-section">Chapter introduction</p>

<p>This chapter builds on top of the concepts from lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-literals-and-operators/">1.9 -- Introduction to literals and operators</a>. A quick review follows:</p>

<p>An <strong>operation</strong> is a mathematical process involving zero or more input values (called <strong>operands</strong>) that produces a new value (called an output value). The specific operation to be performed is denoted by a construct (typically a symbol or pair of symbols) called an <strong>operator</strong>.</p>

<p>For example, as children we all learn that <code>2 + 3</code> equals <code>5</code>. In this case, the literals <code>2</code> and <code>3</code> are the operands, and the symbol <code>+</code> is the operator that tells us to apply mathematical addition on the operands to produce the new value <code>5</code>. Because there is only one operator being used here, this is straightforward.</p>

<p>In this chapter, we'll discuss topics related to operators, and explore many of the common operators that C++ supports.</p>

<p class="cpp-section">Evaluation of compound expressions</p>

<p>Now, let's consider a compound expression, such as <code>4 + 2 * 3</code>. Should this be grouped as <code>(4 + 2) * 3</code> which evaluates to <code>18</code>, or <code>4 + (2 * 3)</code> which evaluates to <code>10</code>? Using normal mathematical precedence rules (which state that multiplication is resolved before addition), we know that the above expression should be grouped as <code>4 + (2 * 3)</code> to produce the value <code>10</code>. But how does the compiler know?</p>

<p>In order to evaluate an expression, the compiler must do two things:</p>
<ul>
    <li>At compile time, the compiler must parse the expression and determine how operands are grouped with operators. This is done via the precedence and associativity rules, which we'll discuss momentarily.</li>
    <li>At compile time or runtime, the operands are evaluated and operations executed to produce a result.</li>
</ul>

<p class="cpp-section">Operator precedence</p>

<p>To assist with parsing a compound expression, all operators are assigned a level of precedence. Operators with a higher <strong>precedence</strong> level are grouped with operands first.</p>

<p>You can see in the table below that multiplication and division (precedence level 5) have a higher precedence level than addition and subtraction (precedence level 6). Thus, multiplication and division will be grouped with operands before addition and subtraction. In other words, <code>4 + 2 * 3</code> will be grouped as <code>4 + (2 * 3)</code>.</p>

<p class="cpp-section">Operator associativity</p>

<p>Consider a compound expression like <code>7 - 4 - 1</code>. Should this be grouped as <code>(7 - 4) - 1</code> which evaluates to <code>2</code>, or <code>7 - (4 - 1)</code>, which evaluates to <code>4</code>? Since both subtraction operators have the same precedence level, the compiler can not use precedence alone to determine how this should be grouped.</p>

<p>If two operators with the same precedence level are adjacent to each other in an expression, the operator's <strong>associativity</strong> tells the compiler whether to evaluate the operators (not the operands!) from left to right or from right to left. Subtraction has precedence level 6, and the operators in precedence level 6 have an associativity of left to right. So this expression is grouped from left to right: <code>(7 - 4) - 1</code>.</p>

<p class="cpp-section">Table of operator precedence and associativity</p>

<p>The below table is primarily meant to be a reference chart that you can refer back to in the future to resolve any precedence or associativity questions you have.</p>

<p>Notes:</p>
<ul>
    <li>Precedence level 1 is the highest precedence level, and level 17 is the lowest. Operators with a higher precedence level have their operands grouped first.</li>
    <li>L->R means left to right associativity.</li>
    <li>R->L means right to left associativity.</li>
</ul>

<table class="cpp-table">
    <thead>
        <tr>
            <th>Prec/Ass</th>
            <th>Operator</th>
            <th>Description</th>
            <th>Pattern</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1 L->R</td>
            <td>::<br>::</td>
            <td>Global scope (unary)<br>Namespace scope (binary)</td>
            <td>::name<br>class_name::member_name</td>
        </tr>
        <tr>
            <td>2 L->R</td>
            <td>()<br>()<br>type()<br>type{}<br>[]<br>.<br>-><br>++<br>--<br>typeid<br>const_cast<br>dynamic_cast<br>reinterpret_cast<br>static_cast<br>sizeof…<br>noexcept<br>alignof</td>
            <td>Parentheses<br>Function call<br>Functional cast<br>List init temporary object (C++11)<br>Array subscript<br>Member access from object<br>Member access from object ptr<br>Post-increment<br>Post-decrement<br>Run-time type information<br>Cast away const<br>Run-time type-checked cast<br>Cast one type to another<br>Compile-time type-checked cast<br>Get parameter pack size<br>Compile-time exception check<br>Get type alignment</td>
            <td>(expression)<br>function_name(arguments)<br>type(expression)<br>type{expression}<br>pointer[expression]<br>object.member_name<br>object_pointer->member_name<br>lvalue++<br>lvalue--<br>typeid(type) or typeid(expression)<br>const_cast&lt;type&gt;(expression)<br>dynamic_cast&lt;type&gt;(expression)<br>reinterpret_cast&lt;type&gt;(expression)<br>static_cast&lt;type&gt;(expression)<br>sizeof…(expression)<br>noexcept(expression)<br>alignof(type)</td>
        </tr>
        <tr>
            <td>3 R->L</td>
            <td>+<br>-<br>++<br>--<br>!<br>not<br>~<br>(type)<br>sizeof<br>co_await<br>&<br>*<br>new<br>new[]<br>delete<br>delete[]</td>
            <td>Unary plus<br>Unary minus<br>Pre-increment<br>Pre-decrement<br>Logical NOT<br>Logical NOT<br>Bitwise NOT<br>C-style cast<br>Size in bytes<br>Await asynchronous call<br>Address of<br>Dereference<br>Dynamic memory allocation<br>Dynamic array allocation<br>Dynamic memory deletion<br>Dynamic array deletion</td>
            <td>+expression<br>-expression<br>++lvalue<br>--lvalue<br>!expression<br>not expression<br>~expression<br>(new_type)expression<br>sizeof(type) or sizeof(expression)<br>co_await expression (C++20)<br>&lvalue<br>*expression<br>new type<br>new type[expression]<br>delete pointer<br>delete[] pointer</td>
        </tr>
        <tr>
            <td>4 L->R</td>
            <td>->*<br>.*</td>
            <td>Member pointer selector<br>Member object selector</td>
            <td>object_pointer->*pointer_to_member<br>object.*pointer_to_member</td>
        </tr>
        <tr>
            <td>5 L->R</td>
            <td>*<br>/<br>%</td>
            <td>Multiplication<br>Division<br>Remainder</td>
            <td>expression * expression<br>expression / expression<br>expression % expression</td>
        </tr>
        <tr>
            <td>6 L->R</td>
            <td>+<br>-</td>
            <td>Addition<br>Subtraction</td>
            <td>expression + expression<br>expression - expression</td>
        </tr>
        <tr>
            <td>7 L->R</td>
            <td><<br>>></td>
            <td>Bitwise shift left / Insertion<br>Bitwise shift right / Extraction</td>
            <td>expression << expression<br>expression >> expression</td>
        </tr>
        <tr>
            <td>8 L->R</td>
            <td><=></td>
            <td>Three-way comparison (C++20)</td>
            <td>expression <=> expression</td>
        </tr>
        <tr>
            <td>9 L->R</td>
            <td><br><=<br>><br>>=</td>
            <td>Comparison less than<br>Comparison less than or equals<br>Comparison greater than<br>Comparison greater than or equals</td>
            <td>expression < expression<br>expression <= expression<br>expression > expression<br>expression >= expression</td>
        </tr>
        <tr>
            <td>10 L->R</td>
            <td>==<br>!=</td>
            <td>Equality<br>Inequality</td>
            <td>expression == expression<br>expression != expression</td>
        </tr>
        <tr>
            <td>11 L->R</td>
            <td>&</td>
            <td>Bitwise AND</td>
            <td>expression & expression</td>
        </tr>
        <tr>
            <td>12 L->R</td>
            <td>^</td>
            <td>Bitwise XOR</td>
            <td>expression ^ expression</td>
        </tr>
        <tr>
            <td>13 L->R</td>
            <td>|</td>
            <td>Bitwise OR</td>
            <td>expression | expression</td>
        </tr>
        <tr>
            <td>14 L->R</td>
            <td>&&<br>and</td>
            <td>Logical AND<br>Logical AND</td>
            <td>expression && expression<br>expression and expression</td>
        </tr>
        <tr>
            <td>15 L->R</td>
            <td>||<br>or</td>
            <td>Logical OR<br>Logical OR</td>
            <td>expression || expression<br>expression or expression</td>
        </tr>
        <tr>
            <td>16 R->L</td>
            <td>throw<br>co_yield<br>?:<br>=<br>*=<br>/=<br>%=<br>+=<br>-=<br><<=<br>>>=<br>&=<br>|=<br>^=</td>
            <td>Throw expression<br>Yield expression (C++20)<br>Conditional<br>Assignment<br>Multiplication assignment<br>Division assignment<br>Remainder assignment<br>Addition assignment<br>Subtraction assignment<br>Bitwise shift left assignment<br>Bitwise shift right assignment<br>Bitwise AND assignment<br>Bitwise OR assignment<br>Bitwise XOR assignment</td>
            <td>throw expression<br>co_yield expression<br>expression ? expression : expression<br>lvalue = expression<br>lvalue *= expression<br>lvalue /= expression<br>lvalue %= expression<br>lvalue += expression<br>lvalue -= expression<br>lvalue <<= expression<br>lvalue >>= expression<br>lvalue &= expression<br>lvalue |= expression<br>lvalue ^= expression</td>
        </tr>
        <tr>
            <td>17 L->R</td>
            <td>,</td>
            <td>Comma operator</td>
            <td>expression, expression</td>
        </tr>
    </tbody>
</table>

<p>You should already recognize a few of these operators, such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>()</code>, and <code>sizeof</code>. However, unless you have experience with another programming language, the majority of the operators in this table will probably be incomprehensible to you right now. That's expected at this point. We'll cover many of them in this chapter, and the rest will be introduced as there is a need for them.</p>

<div class="cpp-note cpp-lightbluebackground">
    <p class="cpp-note-title">Q: Where is the exponent operator?</p>
    <p>C++ doesn't include an operator to do exponentiation (<code>operator^</code> has a different function in C++). We discuss exponentiation more in lesson <a href="https://www.learncpp.com/cpp-tutorial/remainder-and-exponentiation/">6.3 -- Remainder and Exponentiation</a>.</p>
</div>

<p>Note that <code>operator<<</code> handles both bitwise left shift and insertion, and <code>operator>></code> handles both bitwise right shift and extraction. The compiler can determine which operation to perform based on the types of the operands.</p>

<p class="cpp-section">Parenthesization</p>

<p>Due to the precedence rules, <code>4 + 2 * 3</code> will be grouped as <code>4 + (2 * 3)</code>. But what if we actually meant <code>(4 + 2) * 3</code>? Just like in normal mathematics, in C++ we can explicitly use parentheses to set the grouping of operands as we desire. This works because parentheses have one of the highest precedence levels, so parentheses generally evaluate before whatever is inside them.</p>

<p class="cpp-section">Use parenthesis to make compound expressions easier to understand</p>

<p>Now consider an expression like <code>x && y || z</code>. Does this evaluate as <code>(x && y) || z</code> or <code>x && (y || z)</code>? You could look up in the table and see that <code>&&</code> takes precedence over <code>||</code>. But there are so many operators and precedence levels that it's hard to remember them all. And you don't want to have to look up operators all the time to understand how a compound expression evaluates.</p>

<p>In order to reduce mistakes and make your code easier to understand without referencing a precedence table, it's a good idea to parenthesize any non-trivial compound expression, so it's clear what your intent is.</p>

<div class="cpp-note cpp-lightgreenbackground">
    <p class="cpp-note-title">Best practice</p>
    <p>Use parentheses to make it clear how a non-trivial compound expression should evaluate (even if they are technically unnecessary).</p>
</div>

<p>A good rule of thumb is: Parenthesize everything, except addition, subtraction, multiplication, and division.</p>

<p>There is one additional exception to the above best practice: Expressions that have a single assignment operator (and no comma operator) do not need to have the right operand of the assignment wrapped in parenthesis.</p>

<p>For example:</p>

<pre><code class="language-cpp">x = (y + z + w);   // instead of this
x = y + z + w;     // it's okay to do this

x = ((y || z) && w); // instead of this
x = (y || z) && w;   // it's okay to do this

x = (y *= z); // expressions with multiple assignments still benefit from parenthesis</code></pre>

<p>The assignment operators have the second lowest precedence (only the comma operator is lower, and it's rarely used). Therefore, so long as there is only one assignment (and no commas), we know the right operand will fully evaluate before the assignment.</p>

<div class="cpp-note cpp-lightgreenbackground">
    <p class="cpp-note-title">Best practice</p>
    <p>Expressions with a single assignment operator do not need to have the right operand of the assignment wrapped in parenthesis.</p>
</div>

<p class="cpp-section">Value computation of operations</p>

<p>The C++ standard uses the term <strong>value computation</strong> to mean the execution of operators in an expression to produce a value. The precedence and association rules determine the order in which value computation happens.</p>

<p>For example, given the expression <code>4 + 2 * 3</code>, due to the precedence rules this groups as <code>4 + (2 * 3)</code>. The value computation for <code>(2 * 3)</code> must happen first, so that the value computation for <code>4 + 6</code> can be completed.</p>

<p class="cpp-section">Evaluation of operands</p>

<p>The C++ standard (mostly) uses the term <strong>evaluation</strong> to refer to the evaluation of operands (not the evaluation of operators or expressions!). For example, given expression <code>a + b</code>, <code>a</code> will be evaluated to produce some value, and <code>b</code> will be evaluated to produce some value. These values can be then used as operands to <code>operator+</code> for value computation.</p>

<div class="cpp-note cpp-lightgraybackground">
    <p class="cpp-note-title">Nomenclature</p>
    <p>Informally, we typically use the term "evaluates" to mean the evaluation of an entire expression (value computation), not just the operands of an expression.</p>
</div>

<p class="cpp-section">The order of evaluation of operands (including function arguments) is mostly unspecified</p>

<p>In most cases, the order of evaluation for operands and function arguments is unspecified, meaning they may be evaluated in any order.</p>

<p>Consider the following expression:</p>

<pre><code class="language-cpp">a * b + c * d</code></pre>

<p>We know from the precedence and associativity rules above that this expression will be grouped as if we had typed:</p>

<pre><code class="language-cpp">(a * b) + (c * d)</code></pre>

<p>If <code>a</code> is <code>1</code>, <code>b</code> is <code>2</code>, <code>c</code> is <code>3</code>, and <code>d</code> is <code>4</code>, this expression will always compute the value <code>14</code>.</p>

<p>However, the precedence and associativity rules only tell us how operators and operands are grouped and the order in which value computation will occur. They do not tell us the order in which the operands or subexpressions are evaluated. The compiler is free to evaluate operands <code>a</code>, <code>b</code>, <code>c</code>, or <code>d</code> in any order. The compiler is also free to calculate <code>a * b</code> or <code>c * d</code> first.</p>

<p>For most expressions, this is irrelevant. In our sample expression above, it doesn't matter in which order variables <code>a</code>, <code>b</code>, <code>c</code>, or <code>d</code> are evaluated for their values: the value calculated will always be <code>14</code>. There is no ambiguity here.</p>

<p>But it is possible to write expressions where the order of evaluation does matter. Consider this program, which contains a mistake often made by new C++ programmers:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;

int getValue()
{
    std::cout &lt;&lt; "Enter an integer: ";

    int x{};
    std::cin &gt;&gt; x;
    return x;
}

void printCalculation(int x, int y, int z)
{
    std::cout &lt;&lt; x + (y * z);
}

int main()
{
    printCalculation(getValue(), getValue(), getValue()); // this line is ambiguous

    return 0;
}</code></pre>

<p>If you run this program and enter the inputs <code>1</code>, <code>2</code>, and <code>3</code>, you might assume that this program would calculate <code>1 + (2 * 3)</code> and print <code>7</code>. But that is making the assumption that the arguments to <code>printCalculation()</code> will evaluate in left-to-right order (so parameter <code>x</code> gets value <code>1</code>, <code>y</code> gets value <code>2</code>, and <code>z</code> gets value <code>3</code>). If instead, the arguments evaluate in right-to-left order (so parameter <code>z</code> gets value <code>1</code>, <code>y</code> gets value <code>2</code>, and <code>x</code> gets value <code>3</code>), then the program will print <code>5</code> instead.</p>

<div class="cpp-note cpp-lightbluebackground">
    <p class="cpp-note-title">Tip</p>
    <p>The Clang compiler evaluates arguments in left-to-right order. The GCC compiler evaluates arguments in right-to-left order.</p>
    <p>If you'd like to see this behavior for yourself, you can do so on <a href="https://wandbox.org/#">Wandbox</a>. Paste in the above program, enter <code>1 2 3</code> in the <em>Stdin</em> tab, select GCC or Clang, and then compile the program. The output will appear at the bottom of the page (you may have to scroll down to see it). You will note that the output for GCC and Clang differs!</p>
</div>

<p>The above program can be made unambiguous by making each function call to <code>getValue()</code> a separate statement:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;

int getValue()
{
    std::cout &lt;&lt; "Enter an integer: ";

    int x{};
    std::cin &gt;&gt; x;
    return x;
}

void printCalculation(int x, int y, int z)
{
    std::cout &lt;&lt; x + (y * z);
}

int main()
{
    int a{ getValue() }; // will execute first
    int b{ getValue() }; // will execute second
    int c{ getValue() }; // will execute third

    printCalculation(a, b, c); // this line is now unambiguous

    return 0;
}</code></pre>

<p>In this version, <code>a</code> will always have value <code>1</code>, <code>b</code> will have value <code>2</code>, and <code>c</code> will have value <code>3</code>. When the arguments to <code>printCalculation()</code> are evaluated, it doesn't matter which order the argument evaluation happens in -- parameter <code>x</code> will always get value <code>1</code>, <code>y</code> will get value <code>2</code>, and <code>z</code> will get value <code>3</code>. This version will deterministically print <code>7</code>.</p>

<div class="cpp-note cpp-lightbluebackground">
    <p class="cpp-note-title">Key insight</p>
    <p>Operands, function arguments, and subexpressions may be evaluated in any order.</p>
    <p>It is a common mistake to believe that operator precedence and associativity affects order of evaluation. Precedence and associativity is used only to determine how operands are grouped with operators, and the order of value computation.</p>
</div>

<div class="cpp-note cpp-lightredbackground">
    <p class="cpp-note-title">Warning</p>
    <p>Ensure that the expressions (or function calls) you write are not dependent on operand (or argument) evaluation order.</p>
</div>

<div class="cpp-note cpp-lightgraybackground">
    <p class="cpp-note-title">Related content</p>
    <p>Operators with side effects can also cause unexpected evaluation results. We cover this in lesson <a href="https://www.learncpp.com/cpp-tutorial/increment-decrement-operators-and-side-effects/">6.4 -- Increment/decrement operators, and side effects</a>.</p>
</div>

<p class="cpp-section">Quiz time</p>

<div class="quiz">
    <p class="quiz-header">Question #1</p>
    <p>You know from everyday mathematics that expressions inside of parentheses get evaluated first. For example, in the expression <code>(2 + 3) * 4</code>, the <code>(2 + 3)</code> part is evaluated first.</p>

    <p>For this exercise, you are given a set of expressions that have no parentheses. Using the operator precedence and associativity rules in the table above, add parentheses to each expression to make it clear how the compiler will evaluate the expression.</p>

    <p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','Hide Hint')">Show Hint</a></p>

    <div class="wphint" id="cpp_hint_id_0" style="display:none;">
        Hint: Use the pattern column in the table above to determine whether the operator is unary (has one operand) or binary (has two operands). Review the lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-literals-and-operators/">1.9 -- Introduction to literals and operators</a> if you need a refresher on what unary and binary operators are.
    </div>

    <div class="cpp-table">
        <p><strong>Sample problem: x = 2 + 3 % 4</strong></p>
        <p>Binary operator <code>%</code> has higher precedence than operator <code>+</code> or operator <code>=</code>, so it gets evaluated first:</p>
        <p>x = 2 + (3 % 4)</p>
        <p>Binary operator <code>+</code> has a higher precedence than operator <code>=</code>, so it gets evaluated next:</p>
        <p><strong>Final answer: x = (2 + (3 % 4))</strong></p>
        <p>We now no longer need the table above to understand how this expression will evaluate.</p>
    </div>

    <p><strong>a) x = 3 + 4 + 5;</strong></p>
    <p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p>
    <div class="wpsolution" id="cpp_solution_id_0" style="display:none;">
        <p>Binary operator <code>+</code> has higher precedence than <code>=</code>:</p>
        <p>x = (3 + 4 + 5);</p>
        <p>Binary operator <code>+</code> has left to right association:</p>
        <p><strong>Final answer: x = ((3 + 4) + 5);</strong></p>
    </div>

    <p><strong>b) x = y = z;</strong></p>
    <p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p>
    <div class="wpsolution" id="cpp_solution_id_1" style="display:none;">
        <p>Binary operator <code>=</code> has right to left association:</p>
        <p><strong>Final answer: x = (y = z);</strong></p>
    </div>

    <p><strong>c) z *= ++y + 5;</strong></p>
    <p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p>
    <div class="wpsolution" id="cpp_solution_id_2" style="display:none;">
        <p>Unary operator <code>++</code> has the highest precedence:</p>
        <p>z *= (++y) + 5;</p>
        <p>Binary operator <code>+</code> has the next highest precedence:</p>
        <p><strong>Final answer: z *= ((++y) + 5);</strong></p>
    </div>

    <p><strong>d) a || b && c || d;</strong></p>
    <p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p>
    <div class="wpsolution" id="cpp_solution_id_3" style="display:none;">
        <p>Binary operator <code>&&</code> has higher precedence than <code>||</code>:</p>
        <p>a || (b && c) || d;</p>
        <p>Binary operator <code>||</code> has left to right association:</p>
        <p><strong>Final answer: (a || (b && c)) || d;</strong></p>
    </div>
</div>

<div class="prevnext">
    <div class="prevnext-inline">
        <a class="nav-link" href="https://www.learncpp.com/cpp-tutorial/arithmetic-operators/">
            <div class="nav-button nav-button-next">
                <div class="nav-button-text">
                    <div class="nav-button-title">Next lesson</div>
                    <div class="nav-button-lesson">6.2 — Arithmetic operators</div>
                </div>
            </div>
        </a>
        <a class="nav-link" href="/">
            <div class="nav-button nav-button-index">
                <div class="nav-button-text">
                    <div class="nav-button-title">Back to table of contents</div>
                </div>
            </div>
        </a>
        <a class="nav-link" href="https://www.learncpp.com/cpp-tutorial/chapter-5-summary-and-quiz/">
            <div class="nav-button nav-button-prev">
                <div class="nav-button-text">
                    <div class="nav-button-title">Previous lesson</div>
                    <div class="nav-button-lesson">5.x — Chapter 5 summary and quiz</div>
                </div>
            </div>
        </a>
    </div>
</div>

</body>
</html>
